Every profesional project must be divided in phases, to be sure to get an organized flow, manageble, and mesurement.

This will provide:
a. Clarity
b. Identify risks, and take early desicions.
c. Improvements.
d. Repeat the process.

1.Starting point:
Objective-> Understand what should will be done and why.

Identify the problem or necessity.
Define the porpuse, objectives, and scope.
Identify stakeholders.
Justify project.
Select the metodology.

Result-> Initial Document of the project (brief), vision, mision, porpuse.

2.Planification:
Objective-> Know how, and when it will be done.

Analize of requirements (functionals and not functionals)
Create backlog or list of functionalities.
Design of architecture (if apply)
Planification of tasks, cronogram, estimations.
Asign of resources and tools.

Result-> Plan of project, roadmap, structure technical, Checklist initial.

3.Design (UI/UX/Architecture)
Objective: Determine how it will looks like, how will works.

Drafts, wireframes. mockups.
Diagrams (architecture)
Select technical stack.
Validation with users or stakeholders.

Results -> Valid prototypes, system structure, defined styles.

4.Development(build)
Objective: Build the product or service.

Build by iterations or phases.
Versions and control management
Continue Integration, Unit tests.
Validations tests.

Results -> Functional increases, code documented.

Tests and Validations:
Objective-> Ensure Quality, Functionality, usability.

Unit tests, integrations, funcionals and acceptance criteria.
Test usability (UI/UX).
Revision by parts and quality control.

Results -> Product ready to release, critical errors free.

Release and Deployment
Objective -> Put the project in production or real use.

Prepare production environment.
Deployment.
Training Final users.
Final Documentation (user manual, instalation, etc).

Result -> Project working.

Mantainance and continue improvements:
Objective -> Ensure stable and evolution.

Error Fixes post-release.
New functionalities (post-MVP)
Metrics Analisis, retrospective.
Result -> Project evolution, stable and align to real use.

Fase	              Entregables comunes
Inicio	            VisiÃ³n, misiÃ³n, objetivos, canvas, brief
PlanificaciÃ³n	      Backlog, cronograma, estructura de carpetas, stack
DiseÃ±o	            Mockups, wireframes, estilos, guÃ­as UX
Desarrollo	        CÃ³digo fuente, control de versiones, CI/CD
Pruebas	            Casos de prueba, informes QA
Entrega	            Deploy automatizado, manual de usuario
Mantenimiento	      Registro de bugs, mejoras, versiÃ³n nueva
ğŸ§© Proceso Lineal Dividido en Etapas (GuÃ­a de Trabajo Paso a Paso)

âœ… FASE 1: INICIO (DefiniciÃ³n)
ğŸ¯ Objetivo: Entender quÃ© se va a hacer y por quÃ©.

Etapa	DescripciÃ³n	Entregable
1.1	Redactar la visiÃ³n y misiÃ³n del proyecto	Documento breve
1.2	Identificar el problema o necesidad a resolver	Lista de necesidades
1.3	Definir objetivos SMART y alcance del proyecto	Documento de alcance
1.4	Identificar stakeholders clave	Lista de interesados
1.5	Elegir la metodologÃ­a (Ã¡gil, cascada, hÃ­brida)	DecisiÃ³n justificada
1.6	Justificar la viabilidad del proyecto (beneficios)	Documento inicial
ğŸ“Œ Resultado final: Brief inicial del proyecto, visiÃ³n clara.

âœ… FASE 2: PLANIFICACIÃ“N
ğŸ¯ Objetivo: Saber cÃ³mo y cuÃ¡ndo se va a hacer.

Etapa	DescripciÃ³n	Entregable
2.1	Levantar requisitos funcionales y no funcionales	Documento de requisitos
2.2	Crear el backlog inicial o funcionalidades esperadas	Lista priorizada
2.3	DiseÃ±ar la arquitectura base (si aplica)	Diagrama tÃ©cnico
2.4	Estimar tiempos y crear un cronograma o roadmap	Cronograma visual
2.5	Definir herramientas, repositorios y gestiÃ³n de tareas	Setup tÃ©cnico
ğŸ“Œ Resultado final: Roadmap tÃ©cnico, estructura inicial organizada.

âœ… FASE 3: DISEÃ‘O
ğŸ¯ Objetivo: Definir cÃ³mo se verÃ¡ y cÃ³mo funcionarÃ¡ el sistema.

Etapa	DescripciÃ³n	Entregable
3.1	Crear wireframes, mockups o prototipos navegables	Mockups en Figma
3.2	Definir el estilo visual y branding (si aplica)	GuÃ­a de estilos
3.3	Validar con usuarios/stakeholders el diseÃ±o	Feedback recopilado
3.4	Seleccionar el stack tecnolÃ³gico	JustificaciÃ³n tÃ©cnica
3.5	Diagramar la arquitectura UI/API/BD	Diagramas actualizados
ğŸ“Œ Resultado final: Prototipo validado, estilos y arquitectura definidos.

âœ… FASE 4: DESARROLLO
ğŸ¯ Objetivo: Construir el producto por partes funcionales.

Etapa	DescripciÃ³n	Entregable
4.1	Crear la estructura base del frontend y backend	Proyecto inicial
4.2	Implementar mÃ³dulos por iteraciÃ³n (MVP primero)	Funcionalidades
4.3	AÃ±adir pruebas unitarias por mÃ³dulo	Test unitarios
4.4	Integrar control de versiones (Git), ramas, PRs	GitHub/GitLab setup
4.5	Configurar CI/CD inicial (opcional si aplica)	AutomatizaciÃ³n bÃ¡sica
ğŸ“Œ Resultado final: Incrementos funcionales, cÃ³digo organizado.

âœ… FASE 5: PRUEBAS Y VALIDACIÃ“N
ğŸ¯ Objetivo: Asegurar calidad, funcionalidad y experiencia.

Etapa	DescripciÃ³n	Entregable
5.1	Ejecutar tests unitarios y de integraciÃ³n	Resultados de tests
5.2	Validar funcionalidades con stakeholders	ValidaciÃ³n externa
5.3	Realizar pruebas de usabilidad UX/UI	Reporte de observaciones
5.4	CorrecciÃ³n de bugs encontrados	Issues resueltos
5.5	Checklist de validaciÃ³n final	AprobaciÃ³n previa al release
ğŸ“Œ Resultado final: Producto estable, listo para entrega.

âœ… FASE 6: ENTREGA Y DESPLIEGUE
ğŸ¯ Objetivo: Poner en producciÃ³n o entorno real.

Etapa	DescripciÃ³n	Entregable
6.1	Preparar y testear el entorno de producciÃ³n	Entorno funcionando
6.2	Realizar el deploy automatizado o manual	Sistema desplegado
6.3	Crear y entregar manual de usuario	DocumentaciÃ³n
6.4	Capacitar usuarios (si aplica)	SesiÃ³n o guÃ­a
6.5	Confirmar entrega formal con clientes	AprobaciÃ³n o acta
ğŸ“Œ Resultado final: Sistema en producciÃ³n, usuarios capacitados.

âœ… FASE 7: MANTENIMIENTO Y EVOLUCIÃ“N
ğŸ¯ Objetivo: Garantizar estabilidad y mejoras post-lanzamiento.

Etapa	DescripciÃ³n	Entregable
7.1	Registrar errores post-release (bug tracker)	Registro de bugs
7.2	Planificar nuevas versiones (post-MVP)	Backlog V2
7.3	Analizar mÃ©tricas de uso	Informes
7.4	RefactorizaciÃ³n tÃ©cnica si aplica	CÃ³digo limpio
7.5	RetroalimentaciÃ³n de usuarios y mejora continua	Encuestas / feedback
ğŸ“Œ Resultado final: Proyecto evolucionado y mantenido.


Based on the previous procedures and steps, I have analized to separate each block or sequence by guidance, so the main Idea is to work in something, may be a project, function, refactor, task whatever, but to get tracked or work in whatever the task should be separated by little tasks that will be named 

procedureGuidance, each procedureGuidance will have a Name  

 each guide will allow the user to organize the model work by phases, in an order, structured to get results, each guidance will form a list of steps with a description, and each step will be linked to a specific output, each step will have a list of outputs which will have an especific version with an specific status, the step should not have multiple outputs with the status in progress, given a timeframe or release the output should include requirements, all should be completed at the end of the timeframe, but if not, provide justification and provide the list of thing to do for the next timeframe or version